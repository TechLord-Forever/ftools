/*
 * A trace consists of header information and a list of instruction information. 
 * Different instructions have different information, so the main trick is to use 
 * variant type to represent instructions.
 *
 * Since protobuf does not support variant type, the main trick is to use a message 
 * have multiple optional sub-messages, and an id to identify which is the real 
 * sub-message of the message.
 */

syntax = "proto3";

package trace_format;

enum architecture_t
{
  X86    = 0;
  X86_64 = 1;
}

enum typeid_address_t
{
  Bit32 = 0;
  Bit64 = 1;
}

message value_address_t
{
  oneof value {
    uint32 value_32 = 1;
    uint64 value_64 = 2;
  }
}

message address_t
{
  typeid_address_t typeid = 1;
  value_address_t value   = 2;
}

/* register = (name, value) */

message register_t 
{
  string name     = 1;
  address_t value = 2;
}

/* memory = (address, value) */

message memory_t
{
  address_t address = 1;
  uint32 value      = 2;
}

/* call = (address, name, is traced) */

enum typeid_con_info_t
{
	REGREAD  = 0;
	REGWRITE = 1;
	MEMLOAD  = 2;
	MEMSTORE = 3;
}

message value_con_info_t
{
  oneof con_info {
    register_t read_register  = 1;
    register_t write_register = 2;
    memory_t load_memory      = 3;
    memory_t store_memory     = 4;
  }
}
 
message con_info_t
{
  typeid_con_info_t typeid = 1;
  value_con_info_t value   = 2;
}

/* instruction = (thread_id, address, opcode, concrete_info*) */

message instruction_t
{
  uint32 thread_id                  = 1;
  address_t address                 = 2;
  bytes opcode                      = 3;
  string disassemble                = 4;
  repeated con_info_t concrete_info = 5;
}

/* body = (metadata|instruction) */

// enum typeid_body_t
// {
// 	METADATA    = 0x0;
// 	INSTRUCTION = 0x1;
// }

// message body_t
// {
//   required typeid_body_t typeid      = 1;
//   optional metadata_t metadata       = 2;
//   optional instruction_t instruction = 3;
// }

// message chunk_t
// {
//   repeated body_t body = 1;
// }

/* header = (architecture, address size) */

message header_t
{
  architecture_t architecture   = 1;
  typeid_address_t address_size = 2;
}

message chunk_t
{
  repeated instruction_t instructions = 1;
}


/* trace = (header, body*) */

// message trace_t
// {
// 	required header_t header = 0;
// 	repeated body_t body     = 1;
// }
